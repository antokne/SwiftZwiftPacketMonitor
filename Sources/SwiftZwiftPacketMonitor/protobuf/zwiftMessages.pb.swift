// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: zwiftMessages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ZwiftPacketMonitor_Meetup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var tag2: Int32 {
    get {return _storage._tag2}
    set {_uniqueStorage()._tag2 = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var startTime: Int64 {
    get {return _storage._startTime}
    set {_uniqueStorage()._startTime = newValue}
  }

  var distance: UInt32 {
    get {return _storage._distance}
    set {_uniqueStorage()._distance = newValue}
  }

  var tag8: Int32 {
    get {return _storage._tag8}
    set {_uniqueStorage()._tag8 = newValue}
  }

  var meetupInner: ZwiftPacketMonitor_Meetup.MeetupInner {
    get {return _storage._meetupInner ?? ZwiftPacketMonitor_Meetup.MeetupInner()}
    set {_uniqueStorage()._meetupInner = newValue}
  }
  /// Returns true if `meetupInner` has been explicitly set.
  var hasMeetupInner: Bool {return _storage._meetupInner != nil}
  /// Clears the value of `meetupInner`. Subsequent reads from it will return its default value.
  mutating func clearMeetupInner() {_uniqueStorage()._meetupInner = nil}

  var thumbnail: String {
    get {return _storage._thumbnail}
    set {_uniqueStorage()._thumbnail = newValue}
  }

  var duration: Int32 {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  var f14: Int64 {
    get {return _storage._f14}
    set {_uniqueStorage()._f14 = newValue}
  }

  var f17: Int32 {
    get {return _storage._f17}
    set {_uniqueStorage()._f17 = newValue}
  }

  var f18: Int32 {
    get {return _storage._f18}
    set {_uniqueStorage()._f18 = newValue}
  }

  var f22: Int32 {
    get {return _storage._f22}
    set {_uniqueStorage()._f22 = newValue}
  }

  var f23: Int32 {
    get {return _storage._f23}
    set {_uniqueStorage()._f23 = newValue}
  }

  var meetupOnlyView: Int32 {
    get {return _storage._meetupOnlyView}
    set {_uniqueStorage()._meetupOnlyView = newValue}
  }

  var f25: Int32 {
    get {return _storage._f25}
    set {_uniqueStorage()._f25 = newValue}
  }

  var f27: Int32 {
    get {return _storage._f27}
    set {_uniqueStorage()._f27 = newValue}
  }

  var f28: Int32 {
    get {return _storage._f28}
    set {_uniqueStorage()._f28 = newValue}
  }

  var f29: Int32 {
    get {return _storage._f29}
    set {_uniqueStorage()._f29 = newValue}
  }

  var f34: Int32 {
    get {return _storage._f34}
    set {_uniqueStorage()._f34 = newValue}
  }

  var f35: Int32 {
    get {return _storage._f35}
    set {_uniqueStorage()._f35 = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct MeetupInner {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: Int32 {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    var name: String {
      get {return _storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    var description_p: String {
      get {return _storage._description_p}
      set {_uniqueStorage()._description_p = newValue}
    }

    var f7: String {
      get {return _storage._f7}
      set {_uniqueStorage()._f7 = newValue}
    }

    var f8: Int64 {
      get {return _storage._f8}
      set {_uniqueStorage()._f8 = newValue}
    }

    var f9: Int64 {
      get {return _storage._f9}
      set {_uniqueStorage()._f9 = newValue}
    }

    var f10: Int64 {
      get {return _storage._f10}
      set {_uniqueStorage()._f10 = newValue}
    }

    var f11: Int64 {
      get {return _storage._f11}
      set {_uniqueStorage()._f11 = newValue}
    }

    var f12: Int64 {
      get {return _storage._f12}
      set {_uniqueStorage()._f12 = newValue}
    }

    var f13: Int64 {
      get {return _storage._f13}
      set {_uniqueStorage()._f13 = newValue}
    }

    var f14: Int64 {
      get {return _storage._f14}
      set {_uniqueStorage()._f14 = newValue}
    }

    var f15: Int64 {
      get {return _storage._f15}
      set {_uniqueStorage()._f15 = newValue}
    }

    var f16: Int64 {
      get {return _storage._f16}
      set {_uniqueStorage()._f16 = newValue}
    }

    var f17: Int64 {
      get {return _storage._f17}
      set {_uniqueStorage()._f17 = newValue}
    }

    var f18: Int64 {
      get {return _storage._f18}
      set {_uniqueStorage()._f18 = newValue}
    }

    var f22: Int64 {
      get {return _storage._f22}
      set {_uniqueStorage()._f22 = newValue}
    }

    var distance: UInt32 {
      get {return _storage._distance}
      set {_uniqueStorage()._distance = newValue}
    }

    var f25: Int64 {
      get {return _storage._f25}
      set {_uniqueStorage()._f25 = newValue}
    }

    var f29: Int32 {
      get {return _storage._f29}
      set {_uniqueStorage()._f29 = newValue}
    }

    var f30: Int32 {
      get {return _storage._f30}
      set {_uniqueStorage()._f30 = newValue}
    }

    var f31: Int32 {
      get {return _storage._f31}
      set {_uniqueStorage()._f31 = newValue}
    }

    var f32: UInt32 {
      get {return _storage._f32}
      set {_uniqueStorage()._f32 = newValue}
    }

    var f33: UInt32 {
      get {return _storage._f33}
      set {_uniqueStorage()._f33 = newValue}
    }

    var duration: Int32 {
      get {return _storage._duration}
      set {_uniqueStorage()._duration = newValue}
    }

    var f42: Int64 {
      get {return _storage._f42}
      set {_uniqueStorage()._f42 = newValue}
    }

    var f44: Int64 {
      get {return _storage._f44}
      set {_uniqueStorage()._f44 = newValue}
    }

    var f46: Int32 {
      get {return _storage._f46}
      set {_uniqueStorage()._f46 = newValue}
    }

    var f47: Int32 {
      get {return _storage._f47}
      set {_uniqueStorage()._f47 = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ZwiftPacketMonitor_PlayerState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var worldTime: Int64 {
    get {return _storage._worldTime}
    set {_uniqueStorage()._worldTime = newValue}
  }

  var distance: Int32 {
    get {return _storage._distance}
    set {_uniqueStorage()._distance = newValue}
  }

  var roadTime: Int32 {
    get {return _storage._roadTime}
    set {_uniqueStorage()._roadTime = newValue}
  }

  var laps: Int32 {
    get {return _storage._laps}
    set {_uniqueStorage()._laps = newValue}
  }

  var speed: Int32 {
    get {return _storage._speed}
    set {_uniqueStorage()._speed = newValue}
  }

  var roadPosition: Int32 {
    get {return _storage._roadPosition}
    set {_uniqueStorage()._roadPosition = newValue}
  }

  var cadenceUhz: Int32 {
    get {return _storage._cadenceUhz}
    set {_uniqueStorage()._cadenceUhz = newValue}
  }

  var heartrate: Int32 {
    get {return _storage._heartrate}
    set {_uniqueStorage()._heartrate = newValue}
  }

  var power: Int32 {
    get {return _storage._power}
    set {_uniqueStorage()._power = newValue}
  }

  var heading: Int64 {
    get {return _storage._heading}
    set {_uniqueStorage()._heading = newValue}
  }

  var lean: Int32 {
    get {return _storage._lean}
    set {_uniqueStorage()._lean = newValue}
  }

  var climbing: Int32 {
    get {return _storage._climbing}
    set {_uniqueStorage()._climbing = newValue}
  }

  var time: Int32 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  var f19: Int32 {
    get {return _storage._f19}
    set {_uniqueStorage()._f19 = newValue}
  }

  var f20: Int32 {
    get {return _storage._f20}
    set {_uniqueStorage()._f20 = newValue}
  }

  var progress: Int32 {
    get {return _storage._progress}
    set {_uniqueStorage()._progress = newValue}
  }

  var customisationID: Int64 {
    get {return _storage._customisationID}
    set {_uniqueStorage()._customisationID = newValue}
  }

  var justWatching: Int32 {
    get {return _storage._justWatching}
    set {_uniqueStorage()._justWatching = newValue}
  }

  var calories: Int32 {
    get {return _storage._calories}
    set {_uniqueStorage()._calories = newValue}
  }

  var x: Float {
    get {return _storage._x}
    set {_uniqueStorage()._x = newValue}
  }

  var altitude: Float {
    get {return _storage._altitude}
    set {_uniqueStorage()._altitude = newValue}
  }

  var y: Float {
    get {return _storage._y}
    set {_uniqueStorage()._y = newValue}
  }

  var watchingRiderID: Int32 {
    get {return _storage._watchingRiderID}
    set {_uniqueStorage()._watchingRiderID = newValue}
  }

  var groupID: Int32 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  var sport: Int64 {
    get {return _storage._sport}
    set {_uniqueStorage()._sport = newValue}
  }

  /// actual distance moved included lateral movement
  var f34: Float {
    get {return _storage._f34}
    set {_uniqueStorage()._f34 = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ZwiftPacketMonitor_ClientToServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connected: Int32 = 0

  var riderID: Int32 = 0

  var worldTime: Int64 = 0

  var seqno: Int32 = 0

  var state: ZwiftPacketMonitor_PlayerState {
    get {return _state ?? ZwiftPacketMonitor_PlayerState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var tag8: Int64 = 0

  var tag9: Int64 = 0

  var lastUpdate: Int64 = 0

  var tag11: Int64 = 0

  var lastPlayerUpdate: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: ZwiftPacketMonitor_PlayerState? = nil
}

/// string firstName=7;
/// string lastName=8;
/// string timestamp=17;
struct ZwiftPacketMonitor_UnknownMessage1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// int64 tag1=1;
/// UnknownMessage1 tag4=4;
struct ZwiftPacketMonitor_UnknownMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_PlayerUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tag1: Int64 = 0

  var tag2: Int32 = 0

  var tag3: Int32 = 0

  var payload: Data = Data()

  var tag5: Int64 = 0

  var tag6: Int64 = 0

  var tag7: Int64 = 0

  var tag8: Int64 = 0

  var tag9: Int64 = 0

  var tag11: Int64 = 0

  var tag12: Int64 = 0

  var tag14: Int64 = 0

  var tag15: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// player entered world ?
struct ZwiftPacketMonitor_Payload105 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var f1: Int64 {
    get {return _storage._f1}
    set {_uniqueStorage()._f1 = newValue}
  }

  var riderID: Int32 {
    get {return _storage._riderID}
    set {_uniqueStorage()._riderID = newValue}
  }

  var f3: Int32 {
    get {return _storage._f3}
    set {_uniqueStorage()._f3 = newValue}
  }

  /// int32?
  var f4: Int64 {
    get {return _storage._f4}
    set {_uniqueStorage()._f4 = newValue}
  }

  var f5: Int64 {
    get {return _storage._f5}
    set {_uniqueStorage()._f5 = newValue}
  }

  /// int32?
  var f6: Int64 {
    get {return _storage._f6}
    set {_uniqueStorage()._f6 = newValue}
  }

  var firstName: String {
    get {return _storage._firstName}
    set {_uniqueStorage()._firstName = newValue}
  }

  var lastName: String {
    get {return _storage._lastName}
    set {_uniqueStorage()._lastName = newValue}
  }

  var f9: Int64 {
    get {return _storage._f9}
    set {_uniqueStorage()._f9 = newValue}
  }

  var f11: Int64 {
    get {return _storage._f11}
    set {_uniqueStorage()._f11 = newValue}
  }

  var f12: Int32 {
    get {return _storage._f12}
    set {_uniqueStorage()._f12 = newValue}
  }

  var f13: Int32 {
    get {return _storage._f13}
    set {_uniqueStorage()._f13 = newValue}
  }

  var f14: Int32 {
    get {return _storage._f14}
    set {_uniqueStorage()._f14 = newValue}
  }

  var f15: Int32 {
    get {return _storage._f15}
    set {_uniqueStorage()._f15 = newValue}
  }

  var f16: Int32 {
    get {return _storage._f16}
    set {_uniqueStorage()._f16 = newValue}
  }

  var f7Date: String {
    get {return _storage._f7Date}
    set {_uniqueStorage()._f7Date = newValue}
  }

  var f19: Int32 {
    get {return _storage._f19}
    set {_uniqueStorage()._f19 = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ZwiftPacketMonitor_Chat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var riderID: Int32 = 0

  /// 0 if public message
  var toRiderID: Int32 = 0

  /// always value 1 ?
  var f3: Int32 = 0

  var firstName: String = String()

  var lastName: String = String()

  var message: String = String()

  var avatar: String = String()

  var countryCode: Int32 = 0

  var eventSubgroup: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_RideOn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var riderID: Int32 = 0

  var toRiderID: Int32 = 0

  var firstName: String = String()

  var lastName: String = String()

  var countryCode: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_Payload2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var f1: Int32 = 0

  var f2: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_TimeSync {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var riderID: Int32 = 0

  var worldTime: Int64 = 0

  var f3: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// format to be determined
struct ZwiftPacketMonitor_Payload110 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// format to be determined
struct ZwiftPacketMonitor_Payload109 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_EventPositions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: Int32 = 0

  var eventRiderPosition: [ZwiftPacketMonitor_EventPositions.EventRiderPosition] = []

  var numRiders: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct EventRiderPosition {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ?? float distance_covered = 2; 
    var riderID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct ZwiftPacketMonitor_ServerToClient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tag1: Int32 {
    get {return _storage._tag1}
    set {_uniqueStorage()._tag1 = newValue}
  }

  var riderID: Int32 {
    get {return _storage._riderID}
    set {_uniqueStorage()._riderID = newValue}
  }

  var worldTime: Int64 {
    get {return _storage._worldTime}
    set {_uniqueStorage()._worldTime = newValue}
  }

  var seqno: Int32 {
    get {return _storage._seqno}
    set {_uniqueStorage()._seqno = newValue}
  }

  var playerStates: [ZwiftPacketMonitor_PlayerState] {
    get {return _storage._playerStates}
    set {_uniqueStorage()._playerStates = newValue}
  }

  var playerUpdates: [ZwiftPacketMonitor_PlayerUpdate] {
    get {return _storage._playerUpdates}
    set {_uniqueStorage()._playerUpdates = newValue}
  }

  var tag11: Int64 {
    get {return _storage._tag11}
    set {_uniqueStorage()._tag11 = newValue}
  }

  var localIp: String {
    get {return _storage._localIp}
    set {_uniqueStorage()._localIp = newValue}
  }

  var tag15: Int32 {
    get {return _storage._tag15}
    set {_uniqueStorage()._tag15 = newValue}
  }

  var tag17: Int64 {
    get {return _storage._tag17}
    set {_uniqueStorage()._tag17 = newValue}
  }

  var numMsgs: Int32 {
    get {return _storage._numMsgs}
    set {_uniqueStorage()._numMsgs = newValue}
  }

  var msgnum: Int32 {
    get {return _storage._msgnum}
    set {_uniqueStorage()._msgnum = newValue}
  }

  var eventPositions: ZwiftPacketMonitor_EventPositions {
    get {return _storage._eventPositions ?? ZwiftPacketMonitor_EventPositions()}
    set {_uniqueStorage()._eventPositions = newValue}
  }
  /// Returns true if `eventPositions` has been explicitly set.
  var hasEventPositions: Bool {return _storage._eventPositions != nil}
  /// Clears the value of `eventPositions`. Subsequent reads from it will return its default value.
  mutating func clearEventPositions() {_uniqueStorage()._eventPositions = nil}

  var servers1: ZwiftPacketMonitor_Server1 {
    get {return _storage._servers1 ?? ZwiftPacketMonitor_Server1()}
    set {_uniqueStorage()._servers1 = newValue}
  }
  /// Returns true if `servers1` has been explicitly set.
  var hasServers1: Bool {return _storage._servers1 != nil}
  /// Clears the value of `servers1`. Subsequent reads from it will return its default value.
  mutating func clearServers1() {_uniqueStorage()._servers1 = nil}

  var servers2: ZwiftPacketMonitor_Server2 {
    get {return _storage._servers2 ?? ZwiftPacketMonitor_Server2()}
    set {_uniqueStorage()._servers2 = newValue}
  }
  /// Returns true if `servers2` has been explicitly set.
  var hasServers2: Bool {return _storage._servers2 != nil}
  /// Clears the value of `servers2`. Subsequent reads from it will return its default value.
  mutating func clearServers2() {_uniqueStorage()._servers2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ZwiftPacketMonitor_ServerAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var f1: Int32 = 0

  var f2: Int32 = 0

  var ip: String = String()

  var f4: Int32 = 0

  var f5: UInt32 = 0

  var f6: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_ServerPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var f1: Int32 = 0

  var f2: Int32 = 0

  var addresses: [ZwiftPacketMonitor_ServerAddress] = []

  var f4: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_Server2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pool: [ZwiftPacketMonitor_ServerPool] = []

  var f2: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_Server1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresses: [ZwiftPacketMonitor_ServerAddress] = []

  var f2: Int32 = 0

  var f3: Int32 = 0

  var f4: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_WorldAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var worldID: Int32 = 0

  var name: String = String()

  var tag3: Int64 = 0

  var tag5: Int64 = 0

  var worldTime: Int64 = 0

  var clockTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_WorldAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var worldTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_EventSubgroupProtobuf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var name: String = String()

  var rules: Int32 = 0

  var route: Int32 = 0

  var laps: Int32 = 0

  var startLocation: Int32 = 0

  var label: Int32 = 0

  var paceType: Int32 = 0

  var jerseyHash: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZwiftPacketMonitor_RiderAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var f2: Int32 = 0

  var f3: Int32 = 0

  var attributeMessage: ZwiftPacketMonitor_RiderAttributes.AttributeMessage {
    get {return _attributeMessage ?? ZwiftPacketMonitor_RiderAttributes.AttributeMessage()}
    set {_attributeMessage = newValue}
  }
  /// Returns true if `attributeMessage` has been explicitly set.
  var hasAttributeMessage: Bool {return self._attributeMessage != nil}
  /// Clears the value of `attributeMessage`. Subsequent reads from it will return its default value.
  mutating func clearAttributeMessage() {self._attributeMessage = nil}

  var theirID: Int32 = 0

  var f13: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AttributeMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var myID: Int32 = 0

    var theirID: Int32 = 0

    var firstName: String = String()

    var lastName: String = String()

    var countryCode: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _attributeMessage: ZwiftPacketMonitor_RiderAttributes.AttributeMessage? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ZwiftPacketMonitor"

extension ZwiftPacketMonitor_Meetup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Meetup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "tag2"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .standard(proto: "start_time"),
    7: .same(proto: "distance"),
    8: .same(proto: "tag8"),
    10: .standard(proto: "meetup_inner"),
    12: .same(proto: "thumbnail"),
    13: .same(proto: "duration"),
    14: .same(proto: "f14"),
    17: .same(proto: "f17"),
    18: .same(proto: "f18"),
    22: .same(proto: "f22"),
    23: .same(proto: "f23"),
    24: .standard(proto: "meetup_only_view"),
    25: .same(proto: "f25"),
    27: .same(proto: "f27"),
    28: .same(proto: "f28"),
    29: .same(proto: "f29"),
    34: .same(proto: "f34"),
    35: .same(proto: "f35"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _tag2: Int32 = 0
    var _name: String = String()
    var _description_p: String = String()
    var _startTime: Int64 = 0
    var _distance: UInt32 = 0
    var _tag8: Int32 = 0
    var _meetupInner: ZwiftPacketMonitor_Meetup.MeetupInner? = nil
    var _thumbnail: String = String()
    var _duration: Int32 = 0
    var _f14: Int64 = 0
    var _f17: Int32 = 0
    var _f18: Int32 = 0
    var _f22: Int32 = 0
    var _f23: Int32 = 0
    var _meetupOnlyView: Int32 = 0
    var _f25: Int32 = 0
    var _f27: Int32 = 0
    var _f28: Int32 = 0
    var _f29: Int32 = 0
    var _f34: Int32 = 0
    var _f35: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _tag2 = source._tag2
      _name = source._name
      _description_p = source._description_p
      _startTime = source._startTime
      _distance = source._distance
      _tag8 = source._tag8
      _meetupInner = source._meetupInner
      _thumbnail = source._thumbnail
      _duration = source._duration
      _f14 = source._f14
      _f17 = source._f17
      _f18 = source._f18
      _f22 = source._f22
      _f23 = source._f23
      _meetupOnlyView = source._meetupOnlyView
      _f25 = source._f25
      _f27 = source._f27
      _f28 = source._f28
      _f29 = source._f29
      _f34 = source._f34
      _f35 = source._f35
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._tag2) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._startTime) }()
        case 7: try { try decoder.decodeSingularFixed32Field(value: &_storage._distance) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._tag8) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._meetupInner) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._thumbnail) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._duration) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._f14) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._f17) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._f18) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._f22) }()
        case 23: try { try decoder.decodeSingularInt32Field(value: &_storage._f23) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._meetupOnlyView) }()
        case 25: try { try decoder.decodeSingularInt32Field(value: &_storage._f25) }()
        case 27: try { try decoder.decodeSingularInt32Field(value: &_storage._f27) }()
        case 28: try { try decoder.decodeSingularInt32Field(value: &_storage._f28) }()
        case 29: try { try decoder.decodeSingularInt32Field(value: &_storage._f29) }()
        case 34: try { try decoder.decodeSingularInt32Field(value: &_storage._f34) }()
        case 35: try { try decoder.decodeSingularInt32Field(value: &_storage._f35) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._tag2 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tag2, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if _storage._startTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._startTime, fieldNumber: 5)
      }
      if _storage._distance != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._distance, fieldNumber: 7)
      }
      if _storage._tag8 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tag8, fieldNumber: 8)
      }
      if let v = _storage._meetupInner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._thumbnail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._thumbnail, fieldNumber: 12)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._duration, fieldNumber: 13)
      }
      if _storage._f14 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f14, fieldNumber: 14)
      }
      if _storage._f17 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f17, fieldNumber: 17)
      }
      if _storage._f18 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f18, fieldNumber: 18)
      }
      if _storage._f22 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f22, fieldNumber: 22)
      }
      if _storage._f23 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f23, fieldNumber: 23)
      }
      if _storage._meetupOnlyView != 0 {
        try visitor.visitSingularInt32Field(value: _storage._meetupOnlyView, fieldNumber: 24)
      }
      if _storage._f25 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f25, fieldNumber: 25)
      }
      if _storage._f27 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f27, fieldNumber: 27)
      }
      if _storage._f28 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f28, fieldNumber: 28)
      }
      if _storage._f29 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f29, fieldNumber: 29)
      }
      if _storage._f34 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f34, fieldNumber: 34)
      }
      if _storage._f35 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f35, fieldNumber: 35)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_Meetup, rhs: ZwiftPacketMonitor_Meetup) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._tag2 != rhs_storage._tag2 {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._tag8 != rhs_storage._tag8 {return false}
        if _storage._meetupInner != rhs_storage._meetupInner {return false}
        if _storage._thumbnail != rhs_storage._thumbnail {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._f14 != rhs_storage._f14 {return false}
        if _storage._f17 != rhs_storage._f17 {return false}
        if _storage._f18 != rhs_storage._f18 {return false}
        if _storage._f22 != rhs_storage._f22 {return false}
        if _storage._f23 != rhs_storage._f23 {return false}
        if _storage._meetupOnlyView != rhs_storage._meetupOnlyView {return false}
        if _storage._f25 != rhs_storage._f25 {return false}
        if _storage._f27 != rhs_storage._f27 {return false}
        if _storage._f28 != rhs_storage._f28 {return false}
        if _storage._f29 != rhs_storage._f29 {return false}
        if _storage._f34 != rhs_storage._f34 {return false}
        if _storage._f35 != rhs_storage._f35 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_Meetup.MeetupInner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ZwiftPacketMonitor_Meetup.protoMessageName + ".MeetupInner"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    7: .same(proto: "f7"),
    8: .same(proto: "f8"),
    9: .same(proto: "f9"),
    10: .same(proto: "f10"),
    11: .same(proto: "f11"),
    12: .same(proto: "f12"),
    13: .same(proto: "f13"),
    14: .same(proto: "f14"),
    15: .same(proto: "f15"),
    16: .same(proto: "f16"),
    17: .same(proto: "f17"),
    18: .same(proto: "f18"),
    22: .same(proto: "f22"),
    24: .same(proto: "distance"),
    25: .same(proto: "f25"),
    29: .same(proto: "f29"),
    30: .same(proto: "f30"),
    31: .same(proto: "f31"),
    32: .same(proto: "f32"),
    33: .same(proto: "f33"),
    34: .same(proto: "duration"),
    42: .same(proto: "f42"),
    44: .same(proto: "f44"),
    46: .same(proto: "f46"),
    47: .same(proto: "f47"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _name: String = String()
    var _description_p: String = String()
    var _f7: String = String()
    var _f8: Int64 = 0
    var _f9: Int64 = 0
    var _f10: Int64 = 0
    var _f11: Int64 = 0
    var _f12: Int64 = 0
    var _f13: Int64 = 0
    var _f14: Int64 = 0
    var _f15: Int64 = 0
    var _f16: Int64 = 0
    var _f17: Int64 = 0
    var _f18: Int64 = 0
    var _f22: Int64 = 0
    var _distance: UInt32 = 0
    var _f25: Int64 = 0
    var _f29: Int32 = 0
    var _f30: Int32 = 0
    var _f31: Int32 = 0
    var _f32: UInt32 = 0
    var _f33: UInt32 = 0
    var _duration: Int32 = 0
    var _f42: Int64 = 0
    var _f44: Int64 = 0
    var _f46: Int32 = 0
    var _f47: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _description_p = source._description_p
      _f7 = source._f7
      _f8 = source._f8
      _f9 = source._f9
      _f10 = source._f10
      _f11 = source._f11
      _f12 = source._f12
      _f13 = source._f13
      _f14 = source._f14
      _f15 = source._f15
      _f16 = source._f16
      _f17 = source._f17
      _f18 = source._f18
      _f22 = source._f22
      _distance = source._distance
      _f25 = source._f25
      _f29 = source._f29
      _f30 = source._f30
      _f31 = source._f31
      _f32 = source._f32
      _f33 = source._f33
      _duration = source._duration
      _f42 = source._f42
      _f44 = source._f44
      _f46 = source._f46
      _f47 = source._f47
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._f7) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._f8) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._f9) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._f10) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._f11) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._f12) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._f13) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._f14) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._f15) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._f16) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._f17) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._f18) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._f22) }()
        case 24: try { try decoder.decodeSingularFixed32Field(value: &_storage._distance) }()
        case 25: try { try decoder.decodeSingularInt64Field(value: &_storage._f25) }()
        case 29: try { try decoder.decodeSingularInt32Field(value: &_storage._f29) }()
        case 30: try { try decoder.decodeSingularInt32Field(value: &_storage._f30) }()
        case 31: try { try decoder.decodeSingularInt32Field(value: &_storage._f31) }()
        case 32: try { try decoder.decodeSingularFixed32Field(value: &_storage._f32) }()
        case 33: try { try decoder.decodeSingularFixed32Field(value: &_storage._f33) }()
        case 34: try { try decoder.decodeSingularInt32Field(value: &_storage._duration) }()
        case 42: try { try decoder.decodeSingularInt64Field(value: &_storage._f42) }()
        case 44: try { try decoder.decodeSingularInt64Field(value: &_storage._f44) }()
        case 46: try { try decoder.decodeSingularInt32Field(value: &_storage._f46) }()
        case 47: try { try decoder.decodeSingularInt32Field(value: &_storage._f47) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if !_storage._f7.isEmpty {
        try visitor.visitSingularStringField(value: _storage._f7, fieldNumber: 7)
      }
      if _storage._f8 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f8, fieldNumber: 8)
      }
      if _storage._f9 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f9, fieldNumber: 9)
      }
      if _storage._f10 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f10, fieldNumber: 10)
      }
      if _storage._f11 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f11, fieldNumber: 11)
      }
      if _storage._f12 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f12, fieldNumber: 12)
      }
      if _storage._f13 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f13, fieldNumber: 13)
      }
      if _storage._f14 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f14, fieldNumber: 14)
      }
      if _storage._f15 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f15, fieldNumber: 15)
      }
      if _storage._f16 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f16, fieldNumber: 16)
      }
      if _storage._f17 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f17, fieldNumber: 17)
      }
      if _storage._f18 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f18, fieldNumber: 18)
      }
      if _storage._f22 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f22, fieldNumber: 22)
      }
      if _storage._distance != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._distance, fieldNumber: 24)
      }
      if _storage._f25 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f25, fieldNumber: 25)
      }
      if _storage._f29 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f29, fieldNumber: 29)
      }
      if _storage._f30 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f30, fieldNumber: 30)
      }
      if _storage._f31 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f31, fieldNumber: 31)
      }
      if _storage._f32 != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._f32, fieldNumber: 32)
      }
      if _storage._f33 != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._f33, fieldNumber: 33)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._duration, fieldNumber: 34)
      }
      if _storage._f42 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f42, fieldNumber: 42)
      }
      if _storage._f44 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f44, fieldNumber: 44)
      }
      if _storage._f46 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f46, fieldNumber: 46)
      }
      if _storage._f47 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f47, fieldNumber: 47)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_Meetup.MeetupInner, rhs: ZwiftPacketMonitor_Meetup.MeetupInner) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._f7 != rhs_storage._f7 {return false}
        if _storage._f8 != rhs_storage._f8 {return false}
        if _storage._f9 != rhs_storage._f9 {return false}
        if _storage._f10 != rhs_storage._f10 {return false}
        if _storage._f11 != rhs_storage._f11 {return false}
        if _storage._f12 != rhs_storage._f12 {return false}
        if _storage._f13 != rhs_storage._f13 {return false}
        if _storage._f14 != rhs_storage._f14 {return false}
        if _storage._f15 != rhs_storage._f15 {return false}
        if _storage._f16 != rhs_storage._f16 {return false}
        if _storage._f17 != rhs_storage._f17 {return false}
        if _storage._f18 != rhs_storage._f18 {return false}
        if _storage._f22 != rhs_storage._f22 {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._f25 != rhs_storage._f25 {return false}
        if _storage._f29 != rhs_storage._f29 {return false}
        if _storage._f30 != rhs_storage._f30 {return false}
        if _storage._f31 != rhs_storage._f31 {return false}
        if _storage._f32 != rhs_storage._f32 {return false}
        if _storage._f33 != rhs_storage._f33 {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._f42 != rhs_storage._f42 {return false}
        if _storage._f44 != rhs_storage._f44 {return false}
        if _storage._f46 != rhs_storage._f46 {return false}
        if _storage._f47 != rhs_storage._f47 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_PlayerState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayerState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "worldTime"),
    3: .same(proto: "distance"),
    4: .same(proto: "roadTime"),
    5: .same(proto: "laps"),
    6: .same(proto: "speed"),
    8: .same(proto: "roadPosition"),
    9: .same(proto: "cadenceUHz"),
    11: .same(proto: "heartrate"),
    12: .same(proto: "power"),
    13: .same(proto: "heading"),
    14: .same(proto: "lean"),
    15: .same(proto: "climbing"),
    16: .same(proto: "time"),
    19: .same(proto: "f19"),
    20: .same(proto: "f20"),
    21: .same(proto: "progress"),
    22: .same(proto: "customisationId"),
    23: .same(proto: "justWatching"),
    24: .same(proto: "calories"),
    25: .same(proto: "x"),
    26: .same(proto: "altitude"),
    27: .same(proto: "y"),
    28: .same(proto: "watchingRiderId"),
    29: .same(proto: "groupId"),
    31: .same(proto: "sport"),
    34: .same(proto: "f34"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _worldTime: Int64 = 0
    var _distance: Int32 = 0
    var _roadTime: Int32 = 0
    var _laps: Int32 = 0
    var _speed: Int32 = 0
    var _roadPosition: Int32 = 0
    var _cadenceUhz: Int32 = 0
    var _heartrate: Int32 = 0
    var _power: Int32 = 0
    var _heading: Int64 = 0
    var _lean: Int32 = 0
    var _climbing: Int32 = 0
    var _time: Int32 = 0
    var _f19: Int32 = 0
    var _f20: Int32 = 0
    var _progress: Int32 = 0
    var _customisationID: Int64 = 0
    var _justWatching: Int32 = 0
    var _calories: Int32 = 0
    var _x: Float = 0
    var _altitude: Float = 0
    var _y: Float = 0
    var _watchingRiderID: Int32 = 0
    var _groupID: Int32 = 0
    var _sport: Int64 = 0
    var _f34: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _worldTime = source._worldTime
      _distance = source._distance
      _roadTime = source._roadTime
      _laps = source._laps
      _speed = source._speed
      _roadPosition = source._roadPosition
      _cadenceUhz = source._cadenceUhz
      _heartrate = source._heartrate
      _power = source._power
      _heading = source._heading
      _lean = source._lean
      _climbing = source._climbing
      _time = source._time
      _f19 = source._f19
      _f20 = source._f20
      _progress = source._progress
      _customisationID = source._customisationID
      _justWatching = source._justWatching
      _calories = source._calories
      _x = source._x
      _altitude = source._altitude
      _y = source._y
      _watchingRiderID = source._watchingRiderID
      _groupID = source._groupID
      _sport = source._sport
      _f34 = source._f34
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._worldTime) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._distance) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._roadTime) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._laps) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._speed) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._roadPosition) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._cadenceUhz) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._heartrate) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._power) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._heading) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._lean) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._climbing) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._time) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._f19) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._f20) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._progress) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._customisationID) }()
        case 23: try { try decoder.decodeSingularInt32Field(value: &_storage._justWatching) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._calories) }()
        case 25: try { try decoder.decodeSingularFloatField(value: &_storage._x) }()
        case 26: try { try decoder.decodeSingularFloatField(value: &_storage._altitude) }()
        case 27: try { try decoder.decodeSingularFloatField(value: &_storage._y) }()
        case 28: try { try decoder.decodeSingularInt32Field(value: &_storage._watchingRiderID) }()
        case 29: try { try decoder.decodeSingularInt32Field(value: &_storage._groupID) }()
        case 31: try { try decoder.decodeSingularInt64Field(value: &_storage._sport) }()
        case 34: try { try decoder.decodeSingularFloatField(value: &_storage._f34) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._worldTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._worldTime, fieldNumber: 2)
      }
      if _storage._distance != 0 {
        try visitor.visitSingularInt32Field(value: _storage._distance, fieldNumber: 3)
      }
      if _storage._roadTime != 0 {
        try visitor.visitSingularInt32Field(value: _storage._roadTime, fieldNumber: 4)
      }
      if _storage._laps != 0 {
        try visitor.visitSingularInt32Field(value: _storage._laps, fieldNumber: 5)
      }
      if _storage._speed != 0 {
        try visitor.visitSingularInt32Field(value: _storage._speed, fieldNumber: 6)
      }
      if _storage._roadPosition != 0 {
        try visitor.visitSingularInt32Field(value: _storage._roadPosition, fieldNumber: 8)
      }
      if _storage._cadenceUhz != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cadenceUhz, fieldNumber: 9)
      }
      if _storage._heartrate != 0 {
        try visitor.visitSingularInt32Field(value: _storage._heartrate, fieldNumber: 11)
      }
      if _storage._power != 0 {
        try visitor.visitSingularInt32Field(value: _storage._power, fieldNumber: 12)
      }
      if _storage._heading != 0 {
        try visitor.visitSingularInt64Field(value: _storage._heading, fieldNumber: 13)
      }
      if _storage._lean != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lean, fieldNumber: 14)
      }
      if _storage._climbing != 0 {
        try visitor.visitSingularInt32Field(value: _storage._climbing, fieldNumber: 15)
      }
      if _storage._time != 0 {
        try visitor.visitSingularInt32Field(value: _storage._time, fieldNumber: 16)
      }
      if _storage._f19 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f19, fieldNumber: 19)
      }
      if _storage._f20 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f20, fieldNumber: 20)
      }
      if _storage._progress != 0 {
        try visitor.visitSingularInt32Field(value: _storage._progress, fieldNumber: 21)
      }
      if _storage._customisationID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._customisationID, fieldNumber: 22)
      }
      if _storage._justWatching != 0 {
        try visitor.visitSingularInt32Field(value: _storage._justWatching, fieldNumber: 23)
      }
      if _storage._calories != 0 {
        try visitor.visitSingularInt32Field(value: _storage._calories, fieldNumber: 24)
      }
      if _storage._x != 0 {
        try visitor.visitSingularFloatField(value: _storage._x, fieldNumber: 25)
      }
      if _storage._altitude != 0 {
        try visitor.visitSingularFloatField(value: _storage._altitude, fieldNumber: 26)
      }
      if _storage._y != 0 {
        try visitor.visitSingularFloatField(value: _storage._y, fieldNumber: 27)
      }
      if _storage._watchingRiderID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._watchingRiderID, fieldNumber: 28)
      }
      if _storage._groupID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._groupID, fieldNumber: 29)
      }
      if _storage._sport != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sport, fieldNumber: 31)
      }
      if _storage._f34 != 0 {
        try visitor.visitSingularFloatField(value: _storage._f34, fieldNumber: 34)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_PlayerState, rhs: ZwiftPacketMonitor_PlayerState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._worldTime != rhs_storage._worldTime {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._roadTime != rhs_storage._roadTime {return false}
        if _storage._laps != rhs_storage._laps {return false}
        if _storage._speed != rhs_storage._speed {return false}
        if _storage._roadPosition != rhs_storage._roadPosition {return false}
        if _storage._cadenceUhz != rhs_storage._cadenceUhz {return false}
        if _storage._heartrate != rhs_storage._heartrate {return false}
        if _storage._power != rhs_storage._power {return false}
        if _storage._heading != rhs_storage._heading {return false}
        if _storage._lean != rhs_storage._lean {return false}
        if _storage._climbing != rhs_storage._climbing {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._f19 != rhs_storage._f19 {return false}
        if _storage._f20 != rhs_storage._f20 {return false}
        if _storage._progress != rhs_storage._progress {return false}
        if _storage._customisationID != rhs_storage._customisationID {return false}
        if _storage._justWatching != rhs_storage._justWatching {return false}
        if _storage._calories != rhs_storage._calories {return false}
        if _storage._x != rhs_storage._x {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        if _storage._y != rhs_storage._y {return false}
        if _storage._watchingRiderID != rhs_storage._watchingRiderID {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._sport != rhs_storage._sport {return false}
        if _storage._f34 != rhs_storage._f34 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_ClientToServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientToServer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connected"),
    2: .standard(proto: "rider_id"),
    3: .standard(proto: "world_time"),
    4: .same(proto: "seqno"),
    7: .same(proto: "state"),
    8: .same(proto: "tag8"),
    9: .same(proto: "tag9"),
    10: .standard(proto: "last_update"),
    11: .same(proto: "tag11"),
    12: .standard(proto: "last_player_update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.connected) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.riderID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.worldTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.seqno) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.tag8) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.tag9) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.lastUpdate) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.tag11) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.lastPlayerUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.connected != 0 {
      try visitor.visitSingularInt32Field(value: self.connected, fieldNumber: 1)
    }
    if self.riderID != 0 {
      try visitor.visitSingularInt32Field(value: self.riderID, fieldNumber: 2)
    }
    if self.worldTime != 0 {
      try visitor.visitSingularInt64Field(value: self.worldTime, fieldNumber: 3)
    }
    if self.seqno != 0 {
      try visitor.visitSingularInt32Field(value: self.seqno, fieldNumber: 4)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if self.tag8 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag8, fieldNumber: 8)
    }
    if self.tag9 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag9, fieldNumber: 9)
    }
    if self.lastUpdate != 0 {
      try visitor.visitSingularInt64Field(value: self.lastUpdate, fieldNumber: 10)
    }
    if self.tag11 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag11, fieldNumber: 11)
    }
    if self.lastPlayerUpdate != 0 {
      try visitor.visitSingularInt64Field(value: self.lastPlayerUpdate, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_ClientToServer, rhs: ZwiftPacketMonitor_ClientToServer) -> Bool {
    if lhs.connected != rhs.connected {return false}
    if lhs.riderID != rhs.riderID {return false}
    if lhs.worldTime != rhs.worldTime {return false}
    if lhs.seqno != rhs.seqno {return false}
    if lhs._state != rhs._state {return false}
    if lhs.tag8 != rhs.tag8 {return false}
    if lhs.tag9 != rhs.tag9 {return false}
    if lhs.lastUpdate != rhs.lastUpdate {return false}
    if lhs.tag11 != rhs.tag11 {return false}
    if lhs.lastPlayerUpdate != rhs.lastPlayerUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_UnknownMessage1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnknownMessage1"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_UnknownMessage1, rhs: ZwiftPacketMonitor_UnknownMessage1) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_UnknownMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnknownMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_UnknownMessage, rhs: ZwiftPacketMonitor_UnknownMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_PlayerUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayerUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag1"),
    2: .same(proto: "tag2"),
    3: .same(proto: "tag3"),
    4: .same(proto: "payload"),
    5: .same(proto: "tag5"),
    6: .same(proto: "tag6"),
    7: .same(proto: "tag7"),
    8: .same(proto: "tag8"),
    9: .same(proto: "tag9"),
    11: .same(proto: "tag11"),
    12: .same(proto: "tag12"),
    14: .same(proto: "tag14"),
    15: .same(proto: "tag15"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.tag1) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.tag2) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.tag3) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.tag5) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.tag6) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.tag7) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.tag8) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.tag9) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.tag11) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.tag12) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.tag14) }()
      case 15: try { try decoder.decodeSingularInt64Field(value: &self.tag15) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tag1 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag1, fieldNumber: 1)
    }
    if self.tag2 != 0 {
      try visitor.visitSingularInt32Field(value: self.tag2, fieldNumber: 2)
    }
    if self.tag3 != 0 {
      try visitor.visitSingularInt32Field(value: self.tag3, fieldNumber: 3)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 4)
    }
    if self.tag5 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag5, fieldNumber: 5)
    }
    if self.tag6 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag6, fieldNumber: 6)
    }
    if self.tag7 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag7, fieldNumber: 7)
    }
    if self.tag8 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag8, fieldNumber: 8)
    }
    if self.tag9 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag9, fieldNumber: 9)
    }
    if self.tag11 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag11, fieldNumber: 11)
    }
    if self.tag12 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag12, fieldNumber: 12)
    }
    if self.tag14 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag14, fieldNumber: 14)
    }
    if self.tag15 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag15, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_PlayerUpdate, rhs: ZwiftPacketMonitor_PlayerUpdate) -> Bool {
    if lhs.tag1 != rhs.tag1 {return false}
    if lhs.tag2 != rhs.tag2 {return false}
    if lhs.tag3 != rhs.tag3 {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.tag5 != rhs.tag5 {return false}
    if lhs.tag6 != rhs.tag6 {return false}
    if lhs.tag7 != rhs.tag7 {return false}
    if lhs.tag8 != rhs.tag8 {return false}
    if lhs.tag9 != rhs.tag9 {return false}
    if lhs.tag11 != rhs.tag11 {return false}
    if lhs.tag12 != rhs.tag12 {return false}
    if lhs.tag14 != rhs.tag14 {return false}
    if lhs.tag15 != rhs.tag15 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_Payload105: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payload105"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "f1"),
    2: .standard(proto: "rider_id"),
    3: .same(proto: "f3"),
    4: .same(proto: "f4"),
    5: .same(proto: "f5"),
    6: .same(proto: "f6"),
    7: .same(proto: "firstName"),
    8: .same(proto: "lastName"),
    9: .same(proto: "f9"),
    11: .same(proto: "f11"),
    12: .same(proto: "f12"),
    13: .same(proto: "f13"),
    14: .same(proto: "f14"),
    15: .same(proto: "f15"),
    16: .same(proto: "f16"),
    17: .same(proto: "f7date"),
    19: .same(proto: "f19"),
  ]

  fileprivate class _StorageClass {
    var _f1: Int64 = 0
    var _riderID: Int32 = 0
    var _f3: Int32 = 0
    var _f4: Int64 = 0
    var _f5: Int64 = 0
    var _f6: Int64 = 0
    var _firstName: String = String()
    var _lastName: String = String()
    var _f9: Int64 = 0
    var _f11: Int64 = 0
    var _f12: Int32 = 0
    var _f13: Int32 = 0
    var _f14: Int32 = 0
    var _f15: Int32 = 0
    var _f16: Int32 = 0
    var _f7Date: String = String()
    var _f19: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _f1 = source._f1
      _riderID = source._riderID
      _f3 = source._f3
      _f4 = source._f4
      _f5 = source._f5
      _f6 = source._f6
      _firstName = source._firstName
      _lastName = source._lastName
      _f9 = source._f9
      _f11 = source._f11
      _f12 = source._f12
      _f13 = source._f13
      _f14 = source._f14
      _f15 = source._f15
      _f16 = source._f16
      _f7Date = source._f7Date
      _f19 = source._f19
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._f1) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._riderID) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._f3) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._f4) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._f5) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._f6) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._firstName) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._lastName) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._f9) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._f11) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._f12) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._f13) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._f14) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._f15) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._f16) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._f7Date) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._f19) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._f1 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f1, fieldNumber: 1)
      }
      if _storage._riderID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._riderID, fieldNumber: 2)
      }
      if _storage._f3 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f3, fieldNumber: 3)
      }
      if _storage._f4 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f4, fieldNumber: 4)
      }
      if _storage._f5 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f5, fieldNumber: 5)
      }
      if _storage._f6 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f6, fieldNumber: 6)
      }
      if !_storage._firstName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstName, fieldNumber: 7)
      }
      if !_storage._lastName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastName, fieldNumber: 8)
      }
      if _storage._f9 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f9, fieldNumber: 9)
      }
      if _storage._f11 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._f11, fieldNumber: 11)
      }
      if _storage._f12 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f12, fieldNumber: 12)
      }
      if _storage._f13 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f13, fieldNumber: 13)
      }
      if _storage._f14 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f14, fieldNumber: 14)
      }
      if _storage._f15 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f15, fieldNumber: 15)
      }
      if _storage._f16 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f16, fieldNumber: 16)
      }
      if !_storage._f7Date.isEmpty {
        try visitor.visitSingularStringField(value: _storage._f7Date, fieldNumber: 17)
      }
      if _storage._f19 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f19, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_Payload105, rhs: ZwiftPacketMonitor_Payload105) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._f1 != rhs_storage._f1 {return false}
        if _storage._riderID != rhs_storage._riderID {return false}
        if _storage._f3 != rhs_storage._f3 {return false}
        if _storage._f4 != rhs_storage._f4 {return false}
        if _storage._f5 != rhs_storage._f5 {return false}
        if _storage._f6 != rhs_storage._f6 {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        if _storage._f9 != rhs_storage._f9 {return false}
        if _storage._f11 != rhs_storage._f11 {return false}
        if _storage._f12 != rhs_storage._f12 {return false}
        if _storage._f13 != rhs_storage._f13 {return false}
        if _storage._f14 != rhs_storage._f14 {return false}
        if _storage._f15 != rhs_storage._f15 {return false}
        if _storage._f16 != rhs_storage._f16 {return false}
        if _storage._f7Date != rhs_storage._f7Date {return false}
        if _storage._f19 != rhs_storage._f19 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_Chat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Chat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rider_id"),
    2: .standard(proto: "to_rider_id"),
    3: .same(proto: "f3"),
    4: .same(proto: "firstName"),
    5: .same(proto: "lastName"),
    6: .same(proto: "message"),
    7: .same(proto: "avatar"),
    8: .same(proto: "countryCode"),
    11: .same(proto: "eventSubgroup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.riderID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.toRiderID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.f3) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.firstName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.lastName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.countryCode) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.eventSubgroup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.riderID != 0 {
      try visitor.visitSingularInt32Field(value: self.riderID, fieldNumber: 1)
    }
    if self.toRiderID != 0 {
      try visitor.visitSingularInt32Field(value: self.toRiderID, fieldNumber: 2)
    }
    if self.f3 != 0 {
      try visitor.visitSingularInt32Field(value: self.f3, fieldNumber: 3)
    }
    if !self.firstName.isEmpty {
      try visitor.visitSingularStringField(value: self.firstName, fieldNumber: 4)
    }
    if !self.lastName.isEmpty {
      try visitor.visitSingularStringField(value: self.lastName, fieldNumber: 5)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 6)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 7)
    }
    if self.countryCode != 0 {
      try visitor.visitSingularInt32Field(value: self.countryCode, fieldNumber: 8)
    }
    if self.eventSubgroup != 0 {
      try visitor.visitSingularInt32Field(value: self.eventSubgroup, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_Chat, rhs: ZwiftPacketMonitor_Chat) -> Bool {
    if lhs.riderID != rhs.riderID {return false}
    if lhs.toRiderID != rhs.toRiderID {return false}
    if lhs.f3 != rhs.f3 {return false}
    if lhs.firstName != rhs.firstName {return false}
    if lhs.lastName != rhs.lastName {return false}
    if lhs.message != rhs.message {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.eventSubgroup != rhs.eventSubgroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_RideOn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RideOn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rider_id"),
    2: .standard(proto: "to_rider_id"),
    3: .same(proto: "firstName"),
    4: .same(proto: "lastName"),
    5: .same(proto: "countryCode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.riderID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.toRiderID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.firstName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.lastName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.countryCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.riderID != 0 {
      try visitor.visitSingularInt32Field(value: self.riderID, fieldNumber: 1)
    }
    if self.toRiderID != 0 {
      try visitor.visitSingularInt32Field(value: self.toRiderID, fieldNumber: 2)
    }
    if !self.firstName.isEmpty {
      try visitor.visitSingularStringField(value: self.firstName, fieldNumber: 3)
    }
    if !self.lastName.isEmpty {
      try visitor.visitSingularStringField(value: self.lastName, fieldNumber: 4)
    }
    if self.countryCode != 0 {
      try visitor.visitSingularInt32Field(value: self.countryCode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_RideOn, rhs: ZwiftPacketMonitor_RideOn) -> Bool {
    if lhs.riderID != rhs.riderID {return false}
    if lhs.toRiderID != rhs.toRiderID {return false}
    if lhs.firstName != rhs.firstName {return false}
    if lhs.lastName != rhs.lastName {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_Payload2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payload2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "f1"),
    2: .same(proto: "f2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.f1) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.f2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.f1 != 0 {
      try visitor.visitSingularInt32Field(value: self.f1, fieldNumber: 1)
    }
    if self.f2 != 0 {
      try visitor.visitSingularInt64Field(value: self.f2, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_Payload2, rhs: ZwiftPacketMonitor_Payload2) -> Bool {
    if lhs.f1 != rhs.f1 {return false}
    if lhs.f2 != rhs.f2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_TimeSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeSync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rider_id"),
    2: .standard(proto: "world_time"),
    3: .same(proto: "f3"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.riderID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.worldTime) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.f3) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.riderID != 0 {
      try visitor.visitSingularInt32Field(value: self.riderID, fieldNumber: 1)
    }
    if self.worldTime != 0 {
      try visitor.visitSingularInt64Field(value: self.worldTime, fieldNumber: 2)
    }
    if self.f3 != 0 {
      try visitor.visitSingularInt32Field(value: self.f3, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_TimeSync, rhs: ZwiftPacketMonitor_TimeSync) -> Bool {
    if lhs.riderID != rhs.riderID {return false}
    if lhs.worldTime != rhs.worldTime {return false}
    if lhs.f3 != rhs.f3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_Payload110: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payload110"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_Payload110, rhs: ZwiftPacketMonitor_Payload110) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_Payload109: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payload109"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_Payload109, rhs: ZwiftPacketMonitor_Payload109) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_EventPositions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventPositions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    4: .same(proto: "eventRiderPosition"),
    116: .standard(proto: "num_riders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.position) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.eventRiderPosition) }()
      case 116: try { try decoder.decodeSingularInt32Field(value: &self.numRiders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.position != 0 {
      try visitor.visitSingularInt32Field(value: self.position, fieldNumber: 1)
    }
    if !self.eventRiderPosition.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.eventRiderPosition, fieldNumber: 4)
    }
    if self.numRiders != 0 {
      try visitor.visitSingularInt32Field(value: self.numRiders, fieldNumber: 116)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_EventPositions, rhs: ZwiftPacketMonitor_EventPositions) -> Bool {
    if lhs.position != rhs.position {return false}
    if lhs.eventRiderPosition != rhs.eventRiderPosition {return false}
    if lhs.numRiders != rhs.numRiders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_EventPositions.EventRiderPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ZwiftPacketMonitor_EventPositions.protoMessageName + ".EventRiderPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rider_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.riderID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.riderID != 0 {
      try visitor.visitSingularInt32Field(value: self.riderID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_EventPositions.EventRiderPosition, rhs: ZwiftPacketMonitor_EventPositions.EventRiderPosition) -> Bool {
    if lhs.riderID != rhs.riderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_ServerToClient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerToClient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag1"),
    2: .standard(proto: "rider_id"),
    3: .standard(proto: "world_time"),
    4: .same(proto: "seqno"),
    8: .standard(proto: "player_states"),
    9: .standard(proto: "player_updates"),
    11: .same(proto: "tag11"),
    12: .standard(proto: "local_ip"),
    15: .same(proto: "tag15"),
    17: .same(proto: "tag17"),
    18: .standard(proto: "num_msgs"),
    19: .same(proto: "msgnum"),
    23: .standard(proto: "event_positions"),
    24: .same(proto: "servers1"),
    25: .same(proto: "servers2"),
  ]

  fileprivate class _StorageClass {
    var _tag1: Int32 = 0
    var _riderID: Int32 = 0
    var _worldTime: Int64 = 0
    var _seqno: Int32 = 0
    var _playerStates: [ZwiftPacketMonitor_PlayerState] = []
    var _playerUpdates: [ZwiftPacketMonitor_PlayerUpdate] = []
    var _tag11: Int64 = 0
    var _localIp: String = String()
    var _tag15: Int32 = 0
    var _tag17: Int64 = 0
    var _numMsgs: Int32 = 0
    var _msgnum: Int32 = 0
    var _eventPositions: ZwiftPacketMonitor_EventPositions? = nil
    var _servers1: ZwiftPacketMonitor_Server1? = nil
    var _servers2: ZwiftPacketMonitor_Server2? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tag1 = source._tag1
      _riderID = source._riderID
      _worldTime = source._worldTime
      _seqno = source._seqno
      _playerStates = source._playerStates
      _playerUpdates = source._playerUpdates
      _tag11 = source._tag11
      _localIp = source._localIp
      _tag15 = source._tag15
      _tag17 = source._tag17
      _numMsgs = source._numMsgs
      _msgnum = source._msgnum
      _eventPositions = source._eventPositions
      _servers1 = source._servers1
      _servers2 = source._servers2
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._tag1) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._riderID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._worldTime) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._seqno) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._playerStates) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._playerUpdates) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._tag11) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._localIp) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._tag15) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._tag17) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._numMsgs) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._msgnum) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._eventPositions) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._servers1) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._servers2) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._tag1 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tag1, fieldNumber: 1)
      }
      if _storage._riderID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._riderID, fieldNumber: 2)
      }
      if _storage._worldTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._worldTime, fieldNumber: 3)
      }
      if _storage._seqno != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seqno, fieldNumber: 4)
      }
      if !_storage._playerStates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._playerStates, fieldNumber: 8)
      }
      if !_storage._playerUpdates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._playerUpdates, fieldNumber: 9)
      }
      if _storage._tag11 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tag11, fieldNumber: 11)
      }
      if !_storage._localIp.isEmpty {
        try visitor.visitSingularStringField(value: _storage._localIp, fieldNumber: 12)
      }
      if _storage._tag15 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tag15, fieldNumber: 15)
      }
      if _storage._tag17 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tag17, fieldNumber: 17)
      }
      if _storage._numMsgs != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numMsgs, fieldNumber: 18)
      }
      if _storage._msgnum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._msgnum, fieldNumber: 19)
      }
      if let v = _storage._eventPositions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._servers1 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if let v = _storage._servers2 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_ServerToClient, rhs: ZwiftPacketMonitor_ServerToClient) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tag1 != rhs_storage._tag1 {return false}
        if _storage._riderID != rhs_storage._riderID {return false}
        if _storage._worldTime != rhs_storage._worldTime {return false}
        if _storage._seqno != rhs_storage._seqno {return false}
        if _storage._playerStates != rhs_storage._playerStates {return false}
        if _storage._playerUpdates != rhs_storage._playerUpdates {return false}
        if _storage._tag11 != rhs_storage._tag11 {return false}
        if _storage._localIp != rhs_storage._localIp {return false}
        if _storage._tag15 != rhs_storage._tag15 {return false}
        if _storage._tag17 != rhs_storage._tag17 {return false}
        if _storage._numMsgs != rhs_storage._numMsgs {return false}
        if _storage._msgnum != rhs_storage._msgnum {return false}
        if _storage._eventPositions != rhs_storage._eventPositions {return false}
        if _storage._servers1 != rhs_storage._servers1 {return false}
        if _storage._servers2 != rhs_storage._servers2 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_ServerAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "f1"),
    2: .same(proto: "f2"),
    3: .same(proto: "ip"),
    4: .same(proto: "f4"),
    5: .same(proto: "f5"),
    6: .same(proto: "f6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.f1) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.f2) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.f4) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self.f5) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self.f6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.f1 != 0 {
      try visitor.visitSingularInt32Field(value: self.f1, fieldNumber: 1)
    }
    if self.f2 != 0 {
      try visitor.visitSingularInt32Field(value: self.f2, fieldNumber: 2)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 3)
    }
    if self.f4 != 0 {
      try visitor.visitSingularInt32Field(value: self.f4, fieldNumber: 4)
    }
    if self.f5 != 0 {
      try visitor.visitSingularFixed32Field(value: self.f5, fieldNumber: 5)
    }
    if self.f6 != 0 {
      try visitor.visitSingularFixed32Field(value: self.f6, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_ServerAddress, rhs: ZwiftPacketMonitor_ServerAddress) -> Bool {
    if lhs.f1 != rhs.f1 {return false}
    if lhs.f2 != rhs.f2 {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs.f4 != rhs.f4 {return false}
    if lhs.f5 != rhs.f5 {return false}
    if lhs.f6 != rhs.f6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_ServerPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerPool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "f1"),
    2: .same(proto: "f2"),
    3: .same(proto: "addresses"),
    4: .same(proto: "f4"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.f1) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.f2) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.f4) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.f1 != 0 {
      try visitor.visitSingularInt32Field(value: self.f1, fieldNumber: 1)
    }
    if self.f2 != 0 {
      try visitor.visitSingularInt32Field(value: self.f2, fieldNumber: 2)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 3)
    }
    if self.f4 != 0 {
      try visitor.visitSingularInt32Field(value: self.f4, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_ServerPool, rhs: ZwiftPacketMonitor_ServerPool) -> Bool {
    if lhs.f1 != rhs.f1 {return false}
    if lhs.f2 != rhs.f2 {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.f4 != rhs.f4 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_Server2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Server2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
    2: .same(proto: "f2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pool) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.f2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pool.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pool, fieldNumber: 1)
    }
    if self.f2 != 0 {
      try visitor.visitSingularInt32Field(value: self.f2, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_Server2, rhs: ZwiftPacketMonitor_Server2) -> Bool {
    if lhs.pool != rhs.pool {return false}
    if lhs.f2 != rhs.f2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_Server1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Server1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresses"),
    2: .same(proto: "f2"),
    3: .same(proto: "f3"),
    4: .same(proto: "f4"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.f2) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.f3) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.f4) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 1)
    }
    if self.f2 != 0 {
      try visitor.visitSingularInt32Field(value: self.f2, fieldNumber: 2)
    }
    if self.f3 != 0 {
      try visitor.visitSingularInt32Field(value: self.f3, fieldNumber: 3)
    }
    if self.f4 != 0 {
      try visitor.visitSingularInt32Field(value: self.f4, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_Server1, rhs: ZwiftPacketMonitor_Server1) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.f2 != rhs.f2 {return false}
    if lhs.f3 != rhs.f3 {return false}
    if lhs.f4 != rhs.f4 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_WorldAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorldAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "world_id"),
    2: .same(proto: "name"),
    3: .same(proto: "tag3"),
    4: .same(proto: "tag5"),
    6: .standard(proto: "world_time"),
    7: .standard(proto: "clock_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.worldID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.tag3) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.tag5) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.worldTime) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.clockTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.worldID != 0 {
      try visitor.visitSingularInt32Field(value: self.worldID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.tag3 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag3, fieldNumber: 3)
    }
    if self.tag5 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag5, fieldNumber: 4)
    }
    if self.worldTime != 0 {
      try visitor.visitSingularInt64Field(value: self.worldTime, fieldNumber: 6)
    }
    if self.clockTime != 0 {
      try visitor.visitSingularInt64Field(value: self.clockTime, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_WorldAttributes, rhs: ZwiftPacketMonitor_WorldAttributes) -> Bool {
    if lhs.worldID != rhs.worldID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.tag3 != rhs.tag3 {return false}
    if lhs.tag5 != rhs.tag5 {return false}
    if lhs.worldTime != rhs.worldTime {return false}
    if lhs.clockTime != rhs.clockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_WorldAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorldAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "world_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.worldTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.worldTime != 0 {
      try visitor.visitSingularInt64Field(value: self.worldTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_WorldAttribute, rhs: ZwiftPacketMonitor_WorldAttribute) -> Bool {
    if lhs.worldTime != rhs.worldTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_EventSubgroupProtobuf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSubgroupProtobuf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    8: .same(proto: "rules"),
    22: .same(proto: "route"),
    25: .same(proto: "laps"),
    29: .same(proto: "startLocation"),
    30: .same(proto: "label"),
    31: .same(proto: "paceType"),
    36: .same(proto: "jerseyHash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.rules) }()
      case 22: try { try decoder.decodeSingularInt32Field(value: &self.route) }()
      case 25: try { try decoder.decodeSingularInt32Field(value: &self.laps) }()
      case 29: try { try decoder.decodeSingularInt32Field(value: &self.startLocation) }()
      case 30: try { try decoder.decodeSingularInt32Field(value: &self.label) }()
      case 31: try { try decoder.decodeSingularInt32Field(value: &self.paceType) }()
      case 36: try { try decoder.decodeSingularInt32Field(value: &self.jerseyHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.rules != 0 {
      try visitor.visitSingularInt32Field(value: self.rules, fieldNumber: 8)
    }
    if self.route != 0 {
      try visitor.visitSingularInt32Field(value: self.route, fieldNumber: 22)
    }
    if self.laps != 0 {
      try visitor.visitSingularInt32Field(value: self.laps, fieldNumber: 25)
    }
    if self.startLocation != 0 {
      try visitor.visitSingularInt32Field(value: self.startLocation, fieldNumber: 29)
    }
    if self.label != 0 {
      try visitor.visitSingularInt32Field(value: self.label, fieldNumber: 30)
    }
    if self.paceType != 0 {
      try visitor.visitSingularInt32Field(value: self.paceType, fieldNumber: 31)
    }
    if self.jerseyHash != 0 {
      try visitor.visitSingularInt32Field(value: self.jerseyHash, fieldNumber: 36)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_EventSubgroupProtobuf, rhs: ZwiftPacketMonitor_EventSubgroupProtobuf) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.route != rhs.route {return false}
    if lhs.laps != rhs.laps {return false}
    if lhs.startLocation != rhs.startLocation {return false}
    if lhs.label != rhs.label {return false}
    if lhs.paceType != rhs.paceType {return false}
    if lhs.jerseyHash != rhs.jerseyHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_RiderAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RiderAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "f2"),
    3: .same(proto: "f3"),
    4: .same(proto: "attributeMessage"),
    10: .same(proto: "theirId"),
    13: .same(proto: "f13"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.f2) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.f3) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._attributeMessage) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.theirID) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.f13) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.f2 != 0 {
      try visitor.visitSingularInt32Field(value: self.f2, fieldNumber: 2)
    }
    if self.f3 != 0 {
      try visitor.visitSingularInt32Field(value: self.f3, fieldNumber: 3)
    }
    if let v = self._attributeMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.theirID != 0 {
      try visitor.visitSingularInt32Field(value: self.theirID, fieldNumber: 10)
    }
    if self.f13 != 0 {
      try visitor.visitSingularInt32Field(value: self.f13, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_RiderAttributes, rhs: ZwiftPacketMonitor_RiderAttributes) -> Bool {
    if lhs.f2 != rhs.f2 {return false}
    if lhs.f3 != rhs.f3 {return false}
    if lhs._attributeMessage != rhs._attributeMessage {return false}
    if lhs.theirID != rhs.theirID {return false}
    if lhs.f13 != rhs.f13 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZwiftPacketMonitor_RiderAttributes.AttributeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ZwiftPacketMonitor_RiderAttributes.protoMessageName + ".AttributeMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "myId"),
    2: .same(proto: "theirId"),
    3: .same(proto: "firstName"),
    4: .same(proto: "lastName"),
    5: .same(proto: "countryCode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.myID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.theirID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.firstName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.lastName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.countryCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.myID != 0 {
      try visitor.visitSingularInt32Field(value: self.myID, fieldNumber: 1)
    }
    if self.theirID != 0 {
      try visitor.visitSingularInt32Field(value: self.theirID, fieldNumber: 2)
    }
    if !self.firstName.isEmpty {
      try visitor.visitSingularStringField(value: self.firstName, fieldNumber: 3)
    }
    if !self.lastName.isEmpty {
      try visitor.visitSingularStringField(value: self.lastName, fieldNumber: 4)
    }
    if self.countryCode != 0 {
      try visitor.visitSingularInt32Field(value: self.countryCode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZwiftPacketMonitor_RiderAttributes.AttributeMessage, rhs: ZwiftPacketMonitor_RiderAttributes.AttributeMessage) -> Bool {
    if lhs.myID != rhs.myID {return false}
    if lhs.theirID != rhs.theirID {return false}
    if lhs.firstName != rhs.firstName {return false}
    if lhs.lastName != rhs.lastName {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
